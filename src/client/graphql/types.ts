export type Maybe<T> = T | null;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  /** A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format. */
  DateTime: any;
  /** The `Upload` scalar type represents a file upload. */
  Upload: any;
};

export type Address = Node & {
  __typename?: "Address";
  /** An random string generated by shortid package */
  id: Scalars["ID"];
  createdAt: Scalars["DateTime"];
  updatedAt: Scalars["DateTime"];
  zip: Scalars["String"];
  address: Scalars["String"];
  number: Scalars["String"];
  condominium: Condominium;
  city: City;
};

export type AddressInsertInput = {
  zip: Scalars["String"];
  address: Scalars["String"];
  number: Scalars["String"];
  city: Scalars["ID"];
};

export type AuthenticationInput = {
  login: Scalars["String"];
  password: Scalars["String"];
};

export type Block = Node & {
  __typename?: "Block";
  /** An random string generated by shortid package */
  id: Scalars["ID"];
  createdAt: Scalars["DateTime"];
  updatedAt: Scalars["DateTime"];
  name: Scalars["String"];
  number: Scalars["Float"];
  images?: Maybe<Array<Image>>;
  condominium: Condominium;
  locals?: Maybe<Array<Local>>;
};

export type BlockConnection = {
  __typename?: "BlockConnection";
  edges?: Maybe<Array<BlockEdge>>;
  pageInfo?: Maybe<BlockPageInfo>;
  totalCount: Scalars["Int"];
};

export type BlockEdge = {
  __typename?: "BlockEdge";
  cursor?: Maybe<Scalars["String"]>;
  node?: Maybe<Block>;
};

export type BlockInsertInput = {
  name: Scalars["String"];
  number: Scalars["Int"];
  images?: Maybe<Array<Scalars["Upload"]>>;
  condominium?: Maybe<Scalars["ID"]>;
};

export type BlockPageInfo = {
  __typename?: "BlockPageInfo";
  startCursor?: Maybe<Scalars["String"]>;
  endCursor?: Maybe<Scalars["String"]>;
  hasPreviousPage: Scalars["Boolean"];
  hasNextPage: Scalars["Boolean"];
};

export type BlockUpdateInput = {
  name?: Maybe<Scalars["String"]>;
  number?: Maybe<Scalars["Int"]>;
  images?: Maybe<Array<Scalars["Upload"]>>;
  condominium?: Maybe<Scalars["ID"]>;
};

export type ChangePasswordInput = {
  currentPassword: Scalars["String"];
  newPassword: Scalars["String"];
};

export type City = Node & {
  __typename?: "City";
  /** An random string generated by shortid package */
  id: Scalars["ID"];
  createdAt: Scalars["DateTime"];
  updatedAt: Scalars["DateTime"];
  name: Scalars["String"];
  code: Scalars["Float"];
  state: State;
  addresses: Array<Address>;
};

export type CityConnection = {
  __typename?: "CityConnection";
  edges?: Maybe<Array<CityEdge>>;
  pageInfo?: Maybe<CityPageInfo>;
  totalCount: Scalars["Int"];
};

export type CityEdge = {
  __typename?: "CityEdge";
  cursor?: Maybe<Scalars["String"]>;
  node?: Maybe<City>;
};

export type CityPageInfo = {
  __typename?: "CityPageInfo";
  startCursor?: Maybe<Scalars["String"]>;
  endCursor?: Maybe<Scalars["String"]>;
  hasPreviousPage: Scalars["Boolean"];
  hasNextPage: Scalars["Boolean"];
};

export type CitySortInput = {
  name?: Maybe<Order>;
};

export type Condominium = Node & {
  __typename?: "Condominium";
  /** An random string generated by shortid package */
  id: Scalars["ID"];
  createdAt: Scalars["DateTime"];
  updatedAt: Scalars["DateTime"];
  companyName: Scalars["String"];
  cnpj: Scalars["String"];
  character: Scalars["String"];
  blocks: Array<Block>;
  rules: Array<Rule>;
  locals: Array<Local>;
  address: Address;
  people: Array<Person>;
};

export type CondominiumConnection = {
  __typename?: "CondominiumConnection";
  edges?: Maybe<Array<CondominiumEdge>>;
  pageInfo?: Maybe<CondominiumPageInfo>;
  totalCount: Scalars["Int"];
};

export type CondominiumEdge = {
  __typename?: "CondominiumEdge";
  cursor?: Maybe<Scalars["String"]>;
  node?: Maybe<Condominium>;
};

export type CondominiumInsertInput = {
  companyName: Scalars["String"];
  cnpj: Scalars["String"];
  character?: Maybe<Scalars["String"]>;
  address: AddressInsertInput;
  rules?: Maybe<Array<RuleInsertInput>>;
};

export type CondominiumPageInfo = {
  __typename?: "CondominiumPageInfo";
  startCursor?: Maybe<Scalars["String"]>;
  endCursor?: Maybe<Scalars["String"]>;
  hasPreviousPage: Scalars["Boolean"];
  hasNextPage: Scalars["Boolean"];
};

export type CondominiumUpdateInput = {
  companyName?: Maybe<Scalars["String"]>;
  cnpj?: Maybe<Scalars["String"]>;
  character?: Maybe<Scalars["String"]>;
  address?: Maybe<AddressInsertInput>;
  rules?: Maybe<Array<RuleInsertInput>>;
};

export type ForgotInput = {
  login: Scalars["String"];
  callback: Scalars["String"];
};

export enum Gender {
  M = "M",
  F = "F",
  N = "N",
}

export type Image = Node & {
  __typename?: "Image";
  /** An random string generated by shortid package */
  id: Scalars["ID"];
  createdAt: Scalars["DateTime"];
  updatedAt: Scalars["DateTime"];
  name: Scalars["String"];
  aspectRatio: Scalars["Float"];
  ext: Scalars["String"];
  width: Scalars["Float"];
  height: Scalars["Float"];
  size: Scalars["Float"];
  url: Scalars["String"];
  block?: Maybe<Block>;
};

export type ImageConnection = {
  __typename?: "ImageConnection";
  edges?: Maybe<Array<ImageEdge>>;
  pageInfo?: Maybe<ImagePageInfo>;
  totalCount: Scalars["Int"];
};

export type ImageEdge = {
  __typename?: "ImageEdge";
  cursor?: Maybe<Scalars["String"]>;
  node?: Maybe<Image>;
};

export type ImagePageInfo = {
  __typename?: "ImagePageInfo";
  startCursor?: Maybe<Scalars["String"]>;
  endCursor?: Maybe<Scalars["String"]>;
  hasPreviousPage: Scalars["Boolean"];
  hasNextPage: Scalars["Boolean"];
};

export type Local = Node & {
  __typename?: "Local";
  /** An random string generated by shortid package */
  id: Scalars["ID"];
  createdAt: Scalars["DateTime"];
  updatedAt: Scalars["DateTime"];
  name: Scalars["String"];
  description?: Maybe<Scalars["String"]>;
  capacity: Scalars["Float"];
  image?: Maybe<Scalars["String"]>;
  block?: Maybe<Block>;
  condominium: Condominium;
};

export type LocalConnection = {
  __typename?: "LocalConnection";
  edges?: Maybe<Array<LocalEdge>>;
  pageInfo?: Maybe<LocalPageInfo>;
  totalCount: Scalars["Int"];
};

export type LocalEdge = {
  __typename?: "LocalEdge";
  cursor?: Maybe<Scalars["String"]>;
  node?: Maybe<Local>;
};

export type LocalPageInfo = {
  __typename?: "LocalPageInfo";
  startCursor?: Maybe<Scalars["String"]>;
  endCursor?: Maybe<Scalars["String"]>;
  hasPreviousPage: Scalars["Boolean"];
  hasNextPage: Scalars["Boolean"];
};

export type Mutation = {
  __typename?: "Mutation";
  updateUser: User;
  login: User;
  register: User;
  forgot: Scalars["String"];
  changePassword: User;
  evictRefreshCookie: Scalars["Boolean"];
  updateCondominium: Condominium;
  createBlock: Block;
  updateBlock: Block;
  deleteBlock: Block;
};

export type MutationUpdateUserArgs = {
  input: UserUpdateInput;
};

export type MutationLoginArgs = {
  input: AuthenticationInput;
};

export type MutationRegisterArgs = {
  input: UserInsertInput;
};

export type MutationForgotArgs = {
  input: ForgotInput;
};

export type MutationChangePasswordArgs = {
  input: ChangePasswordInput;
};

export type MutationUpdateCondominiumArgs = {
  input: CondominiumUpdateInput;
};

export type MutationCreateBlockArgs = {
  input: BlockInsertInput;
};

export type MutationUpdateBlockArgs = {
  id: Scalars["ID"];
  input: BlockUpdateInput;
};

export type MutationDeleteBlockArgs = {
  id: Scalars["ID"];
};

export type Node = {
  /** An random string generated by shortid package */
  id: Scalars["ID"];
};

export enum Order {
  Asc = "ASC",
  AscNullsLast = "ASC_NULLS_LAST",
  AscNullsFirst = "ASC_NULLS_FIRST",
  Desc = "DESC",
  DescNullsLast = "DESC_NULLS_LAST",
  DescNullsFirst = "DESC_NULLS_FIRST",
}

export type Person = Node & {
  __typename?: "Person";
  /** An random string generated by shortid package */
  id: Scalars["ID"];
  createdAt: Scalars["DateTime"];
  updatedAt: Scalars["DateTime"];
  name: Scalars["String"];
  lastName: Scalars["String"];
  email: Scalars["String"];
  gender: Gender;
  cpf: Scalars["String"];
  color: Scalars["String"];
  birthdate: Scalars["DateTime"];
  phones: Array<Scalars["String"]>;
  user: User;
  condominiums: Array<Condominium>;
};

export type PersonConnection = {
  __typename?: "PersonConnection";
  edges?: Maybe<Array<PersonEdge>>;
  pageInfo?: Maybe<PersonPageInfo>;
  totalCount: Scalars["Int"];
};

export type PersonEdge = {
  __typename?: "PersonEdge";
  cursor?: Maybe<Scalars["String"]>;
  node?: Maybe<Person>;
};

export type PersonInsertInput = {
  name: Scalars["String"];
  lastName: Scalars["String"];
  email: Scalars["String"];
  cpf: Scalars["String"];
  birthdate: Scalars["DateTime"];
  gender: Gender;
  phones: Array<Scalars["String"]>;
  condominiums: Array<CondominiumInsertInput>;
};

export type PersonPageInfo = {
  __typename?: "PersonPageInfo";
  startCursor?: Maybe<Scalars["String"]>;
  endCursor?: Maybe<Scalars["String"]>;
  hasPreviousPage: Scalars["Boolean"];
  hasNextPage: Scalars["Boolean"];
};

export type PersonUpdateInput = {
  name?: Maybe<Scalars["String"]>;
  lastName?: Maybe<Scalars["String"]>;
  email?: Maybe<Scalars["String"]>;
  cpf?: Maybe<Scalars["String"]>;
  birthdate?: Maybe<Scalars["DateTime"]>;
  gender?: Maybe<Gender>;
  phones?: Maybe<Array<Scalars["String"]>>;
};

export type Query = {
  __typename?: "Query";
  showUsers: UserConnection;
  findUserByID: User;
  findUserByLogin: User;
  showPeople: PersonConnection;
  findPersonByID: Person;
  profile: User;
  showCondominiums: CondominiumConnection;
  findCondominiumByID: Condominium;
  currentCondominium: Condominium;
  showStates: StateConnection;
  findStateByID: State;
  showCities: CityConnection;
  findCityByID: City;
  findCitiesByStateID: Array<City>;
  showBlocks: BlockConnection;
  findBlockByID: Block;
  showImages: ImageConnection;
  showLocals: LocalConnection;
  findLocalByID: Local;
};

export type QueryShowUsersArgs = {
  sort?: Maybe<UserSortInput>;
  before?: Maybe<Scalars["String"]>;
  after?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
};

export type QueryFindUserByIdArgs = {
  id: Scalars["ID"];
};

export type QueryFindUserByLoginArgs = {
  login: Scalars["String"];
};

export type QueryShowPeopleArgs = {
  before?: Maybe<Scalars["String"]>;
  after?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
};

export type QueryFindPersonByIdArgs = {
  id: Scalars["ID"];
};

export type QueryShowCondominiumsArgs = {
  before?: Maybe<Scalars["String"]>;
  after?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
};

export type QueryFindCondominiumByIdArgs = {
  id: Scalars["ID"];
};

export type QueryShowStatesArgs = {
  sort?: Maybe<StateSortInput>;
  before?: Maybe<Scalars["String"]>;
  after?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
};

export type QueryFindStateByIdArgs = {
  id: Scalars["ID"];
};

export type QueryShowCitiesArgs = {
  sort?: Maybe<CitySortInput>;
  before?: Maybe<Scalars["String"]>;
  after?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
};

export type QueryFindCityByIdArgs = {
  id: Scalars["ID"];
};

export type QueryFindCitiesByStateIdArgs = {
  id: Scalars["ID"];
};

export type QueryShowBlocksArgs = {
  before?: Maybe<Scalars["String"]>;
  after?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
};

export type QueryFindBlockByIdArgs = {
  id: Scalars["ID"];
};

export type QueryShowImagesArgs = {
  before?: Maybe<Scalars["String"]>;
  after?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
};

export type QueryShowLocalsArgs = {
  before?: Maybe<Scalars["String"]>;
  after?: Maybe<Scalars["String"]>;
  first?: Maybe<Scalars["Int"]>;
  last?: Maybe<Scalars["Int"]>;
};

export type QueryFindLocalByIdArgs = {
  id: Scalars["ID"];
};

export type Rule = Node & {
  __typename?: "Rule";
  /** An random string generated by shortid package */
  id: Scalars["ID"];
  createdAt: Scalars["DateTime"];
  updatedAt: Scalars["DateTime"];
  description: Scalars["String"];
  condominium: Condominium;
};

export type RuleInsertInput = {
  id?: Maybe<Scalars["String"]>;
  description: Scalars["String"];
};

export type State = Node & {
  __typename?: "State";
  /** An random string generated by shortid package */
  id: Scalars["ID"];
  createdAt: Scalars["DateTime"];
  updatedAt: Scalars["DateTime"];
  name: Scalars["String"];
  initials: Scalars["String"];
  code: Scalars["Float"];
  cities: Array<City>;
};

export type StateConnection = {
  __typename?: "StateConnection";
  edges?: Maybe<Array<StateEdge>>;
  pageInfo?: Maybe<StatePageInfo>;
  totalCount: Scalars["Int"];
};

export type StateEdge = {
  __typename?: "StateEdge";
  cursor?: Maybe<Scalars["String"]>;
  node?: Maybe<State>;
};

export type StatePageInfo = {
  __typename?: "StatePageInfo";
  startCursor?: Maybe<Scalars["String"]>;
  endCursor?: Maybe<Scalars["String"]>;
  hasPreviousPage: Scalars["Boolean"];
  hasNextPage: Scalars["Boolean"];
};

export type StateSortInput = {
  name?: Maybe<Order>;
  initials?: Maybe<Order>;
  cities?: Maybe<CitySortInput>;
};

export type User = Node & {
  __typename?: "User";
  /** An random string generated by shortid package */
  id: Scalars["ID"];
  createdAt: Scalars["DateTime"];
  updatedAt: Scalars["DateTime"];
  login: Scalars["String"];
  person: Person;
};

export type UserConnection = {
  __typename?: "UserConnection";
  edges?: Maybe<Array<UserEdge>>;
  pageInfo?: Maybe<UserPageInfo>;
  totalCount: Scalars["Int"];
};

export type UserEdge = {
  __typename?: "UserEdge";
  cursor?: Maybe<Scalars["String"]>;
  node?: Maybe<User>;
};

export type UserInsertInput = {
  login: Scalars["String"];
  password: Scalars["String"];
  person: PersonInsertInput;
};

export type UserPageInfo = {
  __typename?: "UserPageInfo";
  startCursor?: Maybe<Scalars["String"]>;
  endCursor?: Maybe<Scalars["String"]>;
  hasPreviousPage: Scalars["Boolean"];
  hasNextPage: Scalars["Boolean"];
};

export type UserSortInput = {
  login?: Maybe<Order>;
};

export type UserUpdateInput = {
  login?: Maybe<Scalars["String"]>;
  person?: Maybe<PersonUpdateInput>;
};
